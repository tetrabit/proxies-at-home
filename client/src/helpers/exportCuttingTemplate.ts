/**
 * Generate an SVG cutting template for Silhouette Cameo based on current print settings.
 * The SVG can be imported into Silhouette Studio and saved as a .studio3 file.
 */

import { debugLog } from './debug';
import { baseCardWidthMm, baseCardHeightMm } from './layout';
import { PDFDocument, rgb, StandardFonts, type PDFFont } from 'pdf-lib';

// MTG card corner radius
const CARD_CORNER_RADIUS_MM = 2.5;

export interface CuttingTemplateSettings {
    pageWidthMm: number;
    pageHeightMm: number;
    columns: number;
    rows: number;
    bleedMm: number;
    spacingMm: number;
    positionOffsetXMm: number;
    positionOffsetYMm: number;
    portrait: boolean;
    perCardOffsets?: Record<number, { x: number; y: number; rotation: number }>;
    includeCutGuides?: boolean;
}

/**
 * Convert current app settings to cutting template settings
 */
export function settingsToCuttingTemplate(
    pageWidth: number,
    pageHeight: number,
    pageSizeUnit: 'mm' | 'in',
    columns: number,
    rows: number,
    bleedEdge: boolean,
    bleedEdgeWidth: number,
    bleedEdgeUnit: 'mm' | 'in',
    cardSpacingMm: number,
    cardPositionX: number,
    cardPositionY: number,
    portrait: boolean
): CuttingTemplateSettings {
    // Convert page dimensions to mm
    const pageWidthMm = pageSizeUnit === 'in' ? pageWidth * 25.4 : pageWidth;
    const pageHeightMm = pageSizeUnit === 'in' ? pageHeight * 25.4 : pageHeight;

    // Convert bleed to mm
    const bleedMm = bleedEdge
        ? (bleedEdgeUnit === 'in' ? bleedEdgeWidth * 25.4 : bleedEdgeWidth)
        : 0;

    return {
        pageWidthMm,
        pageHeightMm,
        columns,
        rows,
        bleedMm,
        spacingMm: cardSpacingMm,
        positionOffsetXMm: cardPositionX,
        positionOffsetYMm: cardPositionY,
        portrait,
    };
}

/**
 * Calculate card cut positions based on settings
 */
function calculateCardPositions(settings: CuttingTemplateSettings): Array<{ x: number; y: number }> {
    const { pageWidthMm, pageHeightMm, columns, rows, bleedMm, spacingMm, positionOffsetXMm, positionOffsetYMm } = settings;

    // Card slot size (content + bleed on each side)
    const slotWidthMm = baseCardWidthMm + 2 * bleedMm;
    const slotHeightMm = baseCardHeightMm + 2 * bleedMm;

    // Grid dimensions
    const gridWidthMm = columns * slotWidthMm + (columns - 1) * spacingMm;
    const gridHeightMm = rows * slotHeightMm + (rows - 1) * spacingMm;

    // Grid start position (centered on page, plus any offset)
    const startXMm = (pageWidthMm - gridWidthMm) / 2 + positionOffsetXMm;
    const startYMm = (pageHeightMm - gridHeightMm) / 2 + positionOffsetYMm;

    const positions: Array<{ x: number; y: number }> = [];

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < columns; col++) {
            // Slot position
            const slotX = startXMm + col * (slotWidthMm + spacingMm);
            const slotY = startYMm + row * (slotHeightMm + spacingMm);

            // Cut line position is at content edge (offset by bleed from slot edge)
            const cutX = slotX + bleedMm;
            const cutY = slotY + bleedMm;

            positions.push({ x: cutX, y: cutY });
        }
    }

    return positions;
}

/**
 * Generate SVG content for cutting template
 *
 * Uses the same coordinate system as the PDF export (page corner as origin).
 * Portrait mode rotates the entire template 90° clockwise to match paper loaded in portrait orientation.
 */
export function generateCuttingTemplateSVG(settings: CuttingTemplateSettings): string {
    const { pageWidthMm, pageHeightMm, columns, portrait } = settings;

    // Calculate card positions
    const positions = calculateCardPositions(settings);

    // For portrait mode, swap SVG dimensions to rotate the layout
    const svgWidth = portrait ? pageHeightMm : pageWidthMm;
    const svgHeight = portrait ? pageWidthMm : pageHeightMm;

    // Build SVG
    const lines: string[] = [];

    lines.push(`<?xml version="1.0" encoding="UTF-8"?>`);
    lines.push(`<svg xmlns="http://www.w3.org/2000/svg"`);
    lines.push(`     width="${svgWidth}mm"`);
    lines.push(`     height="${svgHeight}mm"`);
    lines.push(`     viewBox="0 0 ${svgWidth} ${svgHeight}">`);
    lines.push(``);
    lines.push(`  <!--`);
    lines.push(`    Cutting template for Silhouette Cameo`);
    lines.push(`    Generated by Proxies at Home`);
    lines.push(`    `);
    lines.push(`    Page: ${svgWidth.toFixed(1)}mm x ${svgHeight.toFixed(1)}mm${portrait ? ' (portrait)' : ''}`);
    lines.push(`    Cards: ${positions.length} standard MTG cards (${baseCardWidthMm}mm x ${baseCardHeightMm}mm) in ${columns}x${settings.rows} grid`);
    lines.push(`    Bleed: ${settings.bleedMm}mm`);
    lines.push(`    Spacing: ${settings.spacingMm}mm`);
    lines.push(`    Corner radius: ${CARD_CORNER_RADIUS_MM}mm`);
    lines.push(`  -->`);
    lines.push(``);
    lines.push(`  <style>`);
    lines.push(`    .cut-line {`);
    lines.push(`      fill: none;`);
    lines.push(`      stroke: #FF0000;`);
    lines.push(`      stroke-width: 0.1;`);
    lines.push(`    }`);
    lines.push(`  </style>`);
    lines.push(``);

    // Invisible corner anchors to establish page bounds without creating cut lines
    lines.push(`  <!-- Page boundary anchors (no stroke, establishes bounding box) -->`);
    lines.push(`  <circle cx="0" cy="0" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="${svgWidth}" cy="0" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="0" cy="${svgHeight}" r="0.01" fill="none" stroke="none"/>`);
    lines.push(`  <circle cx="${svgWidth}" cy="${svgHeight}" r="0.01" fill="none" stroke="none"/>`);
    lines.push(``);

    // Add rectangles for each card
    lines.push(`  <!-- Card cut lines -->`);
    positions.forEach((pos, idx) => {
        const row = Math.floor(idx / columns);
        if (idx % columns === 0) {
            lines.push(`  <!-- Row ${row + 1} -->`);
        }

        let x: number, y: number, w: number, h: number;
        if (portrait) {
            // 90° clockwise rotation: (x, y) -> (y, pageWidth - x - cardWidth)
            x = pos.y;
            y = pageWidthMm - pos.x - baseCardWidthMm;
            w = baseCardHeightMm;
            h = baseCardWidthMm;
        } else {
            x = pos.x;
            y = pos.y;
            w = baseCardWidthMm;
            h = baseCardHeightMm;
        }

        lines.push(`  <rect class="cut-line" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${w}" height="${h}" rx="${CARD_CORNER_RADIUS_MM}" ry="${CARD_CORNER_RADIUS_MM}"/>`);
    });

    lines.push(``);
    lines.push(`</svg>`);

    return lines.join('\n');
}

/**
 * Download the cutting template as an SVG file
 */
export function downloadCuttingTemplate(settings: CuttingTemplateSettings): void {
    const svg = generateCuttingTemplateSVG(settings);
    const blob = new Blob([svg], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);

    const { pageWidthMm, pageHeightMm, columns, rows, bleedMm, portrait } = settings;
    debugLog('[SVG Export] Settings:', { pageWidthMm, pageHeightMm, portrait, columns, rows });
    const pageName = getPageSizeName(pageWidthMm, pageHeightMm);
    const orientation = portrait ? 'portrait' : 'landscape';
    const filename = `cutting_template_${pageName}_${columns}x${rows}_${bleedMm}mm_bleed_${orientation}.svg`;
    debugLog('[SVG Export] Filename:', filename);

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/**
 * Get a human-readable page size name
 */
function getPageSizeName(widthMm: number, heightMm: number): string {
    // Check common sizes (with small tolerance for floating point)
    const tolerance = 1;

    const sizes: Array<{ name: string; w: number; h: number }> = [
        { name: 'letter', w: 215.9, h: 279.4 },
        { name: 'letter_landscape', w: 279.4, h: 215.9 },
        { name: 'a4', w: 210, h: 297 },
        { name: 'a4_landscape', w: 297, h: 210 },
        { name: 'tabloid', w: 279.4, h: 431.8 },
        { name: 'tabloid_landscape', w: 431.8, h: 279.4 },
        { name: 'a3', w: 297, h: 420 },
        { name: 'a3_landscape', w: 420, h: 297 },
        { name: 'legal', w: 215.9, h: 355.6 },
        { name: 'legal_landscape', w: 355.6, h: 215.9 },
    ];

    for (const size of sizes) {
        if (Math.abs(widthMm - size.w) < tolerance && Math.abs(heightMm - size.h) < tolerance) {
            return size.name;
        }
    }

    return `${Math.round(widthMm)}x${Math.round(heightMm)}mm`;
}

/**
 * Draw a rounded rectangle by drawing edges and corner arcs separately
 */
function drawRoundedRect(
    page: ReturnType<PDFDocument['addPage']>,
    x: number,
    y: number,
    width: number,
    height: number,
    radius: number,
    color: [number, number, number],
    lineWidth: number
) {
    const r = Math.min(radius, width / 2, height / 2);
    const rgbColor = rgb(...color);

    // Draw four straight edges
    // Top edge (horizontal line from left corner to right corner)
    page.drawLine({
        start: { x: x + r, y: y },
        end: { x: x + width - r, y: y },
        thickness: lineWidth,
        color: rgbColor,
    });

    // Right edge
    page.drawLine({
        start: { x: x + width, y: y + r },
        end: { x: x + width, y: y + height - r },
        thickness: lineWidth,
        color: rgbColor,
    });

    // Bottom edge
    page.drawLine({
        start: { x: x + width - r, y: y + height },
        end: { x: x + r, y: y + height },
        thickness: lineWidth,
        color: rgbColor,
    });

    // Left edge
    page.drawLine({
        start: { x: x, y: y + height - r },
        end: { x: x, y: y + r },
        thickness: lineWidth,
        color: rgbColor,
    });

    // Draw rounded corners using quarter circles
    const segments = 12; // Number of line segments per corner for smooth curves

    // Helper function to draw a quarter circle arc
    const drawArc = (centerX: number, centerY: number, startAngle: number) => {
        for (let i = 0; i < segments; i++) {
            const angle1 = startAngle + (i / segments) * (Math.PI / 2);
            const angle2 = startAngle + ((i + 1) / segments) * (Math.PI / 2);

            const x1 = centerX + r * Math.cos(angle1);
            const y1 = centerY + r * Math.sin(angle1);
            const x2 = centerX + r * Math.cos(angle2);
            const y2 = centerY + r * Math.sin(angle2);

            page.drawLine({
                start: { x: x1, y: y1 },
                end: { x: x2, y: y2 },
                thickness: lineWidth,
                color: rgbColor,
            });
        }
    };

    // Top-left corner (starts at 180° = PI, goes to 270° = 3PI/2)
    drawArc(x + r, y + r, Math.PI);

    // Top-right corner (starts at 270° = 3PI/2, goes to 360° = 0)
    drawArc(x + width - r, y + r, 3 * Math.PI / 2);

    // Bottom-right corner (starts at 0°, goes to 90° = PI/2)
    drawArc(x + width - r, y + height - r, 0);

    // Bottom-left corner (starts at 90° = PI/2, goes to 180° = PI)
    drawArc(x + r, y + height - r, Math.PI / 2);
}

function drawPageCutGuides(
    page: ReturnType<PDFDocument['addPage']>,
    positions: Array<{ x: number; y: number }>,
    columns: number,
    pageWidthMm: number,
    pageHeightMm: number,
    guideColor: [number, number, number] = [0, 0, 0],
    lineWidth: number = 0.3
) {
    const MM_TO_PT = 2.83465;
    const pdfHeight = pageHeightMm;

    const xCuts = new Set<number>();
    const yCuts = new Set<number>();

    positions.forEach((pos) => {
        xCuts.add(pos.x);
        xCuts.add(pos.x + baseCardWidthMm);
        yCuts.add(pos.y);
        yCuts.add(pos.y + baseCardHeightMm);
    });

    const rgbColor = rgb(...guideColor);

    for (const x of xCuts) {
        const pdfX = x * MM_TO_PT;
        page.drawLine({
            start: { x: pdfX, y: 0 },
            end: { x: pdfX, y: pdfHeight * MM_TO_PT },
            thickness: lineWidth,
            color: rgbColor,
        });
    }

    for (const y of yCuts) {
        const pdfY = (pdfHeight - y) * MM_TO_PT;
        page.drawLine({
            start: { x: 0, y: pdfY },
            end: { x: pageWidthMm * MM_TO_PT, y: pdfY },
            thickness: lineWidth,
            color: rgbColor,
        });
    }
}

/**
 * Draw card placeholders on a page
 */
function drawCardPlaceholders(
    page: ReturnType<PDFDocument['addPage']>,
    positions: Array<{ x: number; y: number }>,
    columns: number,
    pageWidthMm: number,
    pageHeightMm: number,
    helveticaFont: PDFFont,
    helveticaBoldFont: PDFFont,
    pageLabel: string,
    perCardOffsets?: Record<number, { x: number; y: number; rotation: number }>,
    showLabels = true
) {
    const MM_TO_PT = 2.83465;
    const pdfWidth = pageWidthMm;
    const pdfHeight = pageHeightMm;

    positions.forEach((pos, index) => {
        const row = Math.floor(index / columns);
        const col = index % columns;

        // Use positions and dimensions directly (no rotation for test PDF)
        let x = pos.x;
        let y = pos.y;
        const w = baseCardWidthMm;
        const h = baseCardHeightMm;

        // Apply per-card offsets if provided
        const cardOffset = perCardOffsets?.[index];
        if (cardOffset) {
            x += cardOffset.x;
            y += cardOffset.y; // Positive = down, negative = up
        }

        // Convert to PDF coordinates (PDF origin is bottom-left)
        let pdfX = x * MM_TO_PT;
        let pdfY = (pdfHeight - y - h) * MM_TO_PT;
        const pdfW = w * MM_TO_PT;
        const pdfH = h * MM_TO_PT;

        const rotation = cardOffset?.rotation || 0;

        // Draw rounded rectangle matching SVG style
        const radius = CARD_CORNER_RADIUS_MM * MM_TO_PT;

        if (rotation !== 0) {
            // For rotated cards, draw rectangle with properly rounded corners
            const centerX = pdfX + pdfW / 2;
            const centerY = pdfY + pdfH / 2;
            // Negate angle for clockwise rotation (PDF Y-axis points up)
            const angleRad = (-rotation * Math.PI) / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            const halfW = pdfW / 2;
            const halfH = pdfH / 2;

            // Helper to rotate a point around center
            const rotatePoint = (dx: number, dy: number): [number, number] => {
                const rotX = dx * cosA - dy * sinA;
                const rotY = dx * sinA + dy * cosA;
                return [centerX + rotX, centerY + rotY];
            };

            // Draw four straight edges
            // Top edge
            const topLeft = rotatePoint(-halfW + radius, -halfH);
            const topRight = rotatePoint(halfW - radius, -halfH);
            page.drawLine({
                start: { x: topLeft[0], y: topLeft[1] },
                end: { x: topRight[0], y: topRight[1] },
                thickness: 0.5,
                color: rgb(1, 0, 0),
            });

            // Right edge
            const rightTop = rotatePoint(halfW, -halfH + radius);
            const rightBottom = rotatePoint(halfW, halfH - radius);
            page.drawLine({
                start: { x: rightTop[0], y: rightTop[1] },
                end: { x: rightBottom[0], y: rightBottom[1] },
                thickness: 0.5,
                color: rgb(1, 0, 0),
            });

            // Bottom edge
            const bottomRight = rotatePoint(halfW - radius, halfH);
            const bottomLeft = rotatePoint(-halfW + radius, halfH);
            page.drawLine({
                start: { x: bottomRight[0], y: bottomRight[1] },
                end: { x: bottomLeft[0], y: bottomLeft[1] },
                thickness: 0.5,
                color: rgb(1, 0, 0),
            });

            // Left edge
            const leftBottom = rotatePoint(-halfW, halfH - radius);
            const leftTop = rotatePoint(-halfW, -halfH + radius);
            page.drawLine({
                start: { x: leftBottom[0], y: leftBottom[1] },
                end: { x: leftTop[0], y: leftTop[1] },
                thickness: 0.5,
                color: rgb(1, 0, 0),
            });

            // Draw rounded corners using multiple line segments for smooth arcs
            const arcSegments = 8;
            const drawCornerArc = (centerOffsetX: number, centerOffsetY: number, startAngle: number) => {
                const arcCenter = rotatePoint(centerOffsetX, centerOffsetY);

                for (let i = 0; i < arcSegments; i++) {
                    const a1 = startAngle + (i / arcSegments) * (Math.PI / 2);
                    const a2 = startAngle + ((i + 1) / arcSegments) * (Math.PI / 2);

                    // Arc points in local space
                    const p1Local = [radius * Math.cos(a1), radius * Math.sin(a1)];
                    const p2Local = [radius * Math.cos(a2), radius * Math.sin(a2)];

                    // Rotate arc points by card rotation
                    const p1x = p1Local[0] * cosA - p1Local[1] * sinA;
                    const p1y = p1Local[0] * sinA + p1Local[1] * cosA;
                    const p2x = p2Local[0] * cosA - p2Local[1] * sinA;
                    const p2y = p2Local[0] * sinA + p2Local[1] * cosA;

                    page.drawLine({
                        start: { x: arcCenter[0] + p1x, y: arcCenter[1] + p1y },
                        end: { x: arcCenter[0] + p2x, y: arcCenter[1] + p2y },
                        thickness: 0.5,
                        color: rgb(1, 0, 0),
                    });
                }
            };

            // Draw four corner arcs
            drawCornerArc(-halfW + radius, -halfH + radius, Math.PI);        // Top-left
            drawCornerArc(halfW - radius, -halfH + radius, 3 * Math.PI / 2); // Top-right
            drawCornerArc(halfW - radius, halfH - radius, 0);                // Bottom-right
            drawCornerArc(-halfW + radius, halfH - radius, Math.PI / 2);     // Bottom-left

            // Update pdfX, pdfY to center for label positioning
            pdfX = centerX - pdfW / 2;
            pdfY = centerY - pdfH / 2;
        } else {
            // No rotation - draw normal rounded rectangle
            drawRoundedRect(page, pdfX, pdfY, pdfW, pdfH, radius, [1, 0, 0], 0.5);
        }

        // Draw labels only if requested (for back page only)
        if (showLabels) {
            // Draw card number and position labels
            const cardNumber = (index + 1).toString();
            const positionLabel = `R${row + 1} C${col + 1}`;

            // Card number (large, bold, centered)
            const numberFontSize = 24;
            const numberWidth = helveticaBoldFont.widthOfTextAtSize(cardNumber, numberFontSize);
            const numberX = pdfX + (pdfW - numberWidth) / 2;
            const numberY = pdfY + pdfH / 2 + 5;

            page.drawText(cardNumber, {
                x: numberX,
                y: numberY,
                size: numberFontSize,
                font: helveticaBoldFont,
                color: rgb(0.4, 0.4, 0.4),
            });

            // Position label (smaller, below number)
            const labelFontSize = 10;
            const labelWidth = helveticaFont.widthOfTextAtSize(positionLabel, labelFontSize);
            const labelX = pdfX + (pdfW - labelWidth) / 2;
            const labelY = pdfY + pdfH / 2 - 15;

            page.drawText(positionLabel, {
                x: labelX,
                y: labelY,
                size: labelFontSize,
                font: helveticaFont,
                color: rgb(0.5, 0.5, 0.5),
            });

            // Show offset values if card has any offsets
            if (cardOffset) {
                const offsetX = cardOffset.x || 0;
                const offsetY = cardOffset.y || 0;
                const rotation = cardOffset.rotation || 0;

                const offsetInfoSize = 7;
                let offsetY_text = pdfY + pdfH - 15;

                // X offset
                if (offsetX !== 0) {
                    const xText = `X: ${offsetX >= 0 ? '+' : ''}${offsetX.toFixed(2)}mm`;
                    const xTextWidth = helveticaFont.widthOfTextAtSize(xText, offsetInfoSize);
                    const xTextX = pdfX + (pdfW - xTextWidth) / 2;

                    page.drawText(xText, {
                        x: xTextX,
                        y: offsetY_text,
                        size: offsetInfoSize,
                        font: helveticaFont,
                        color: rgb(0.2, 0.6, 0.2),
                    });
                    offsetY_text -= 9;
                }

                // Y offset
                if (offsetY !== 0) {
                    const yText = `Y: ${offsetY >= 0 ? '+' : ''}${offsetY.toFixed(2)}mm`;
                    const yTextWidth = helveticaFont.widthOfTextAtSize(yText, offsetInfoSize);
                    const yTextX = pdfX + (pdfW - yTextWidth) / 2;

                    page.drawText(yText, {
                        x: yTextX,
                        y: offsetY_text,
                        size: offsetInfoSize,
                        font: helveticaFont,
                        color: rgb(0.2, 0.6, 0.2),
                    });
                    offsetY_text -= 9;
                }

                // Rotation
                if (rotation !== 0) {
                    const rotText = `R: ${rotation >= 0 ? '+' : ''}${rotation.toFixed(1)}°`;
                    const rotTextWidth = helveticaFont.widthOfTextAtSize(rotText, offsetInfoSize);
                    const rotTextX = pdfX + (pdfW - rotTextWidth) / 2;

                    page.drawText(rotText, {
                        x: rotTextX,
                        y: offsetY_text,
                        size: offsetInfoSize,
                        font: helveticaFont,
                        color: rgb(0.8, 0.4, 0.0),
                    });
                }
            }
        }
    });

    // Draw page label in bottom right corner
    const pageLabelFontSize = 14;
    const pageLabelWidth = helveticaFont.widthOfTextAtSize(pageLabel, pageLabelFontSize);

    page.drawText(pageLabel, {
        x: (pdfWidth * MM_TO_PT) - pageLabelWidth - 20,
        y: 20,
        size: pageLabelFontSize,
        font: helveticaFont,
        color: rgb(0.3, 0.3, 0.3),
    });
}

/**
 * Export the cutting template as a two-page duplex PDF for alignment checking
 */
export async function downloadCuttingTemplatePDF(settings: CuttingTemplateSettings): Promise<void> {
    const { pageWidthMm, pageHeightMm, columns, rows, bleedMm, portrait, perCardOffsets, includeCutGuides = true } = settings;

    // Calculate card positions
    const positions = calculateCardPositions(settings);

    // Use page dimensions directly (no rotation for test PDF)
    const pdfWidth = pageWidthMm;
    const pdfHeight = pageHeightMm;

    // Create PDF document
    const pdfDoc = await PDFDocument.create();

    // Embed fonts
    const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    // Convert mm to points
    const MM_TO_PT = 2.83465;

    // Create FRONT page (baseline - no labels, no offsets)
    const frontPage = pdfDoc.addPage([pdfWidth * MM_TO_PT, pdfHeight * MM_TO_PT]);
    if (includeCutGuides) {
        drawPageCutGuides(frontPage, positions, columns, pageWidthMm, pageHeightMm);
    }
    drawCardPlaceholders(
        frontPage,
        positions,
        columns,
        pageWidthMm,
        pageHeightMm,
        helveticaFont,
        helveticaBoldFont,
        'front',
        undefined, // No offsets on front - it's the baseline
        false // Don't show labels on front
    );

    // Create BACK page (with labels and offsets applied)
    const backPage = pdfDoc.addPage([pdfWidth * MM_TO_PT, pdfHeight * MM_TO_PT]);
    if (includeCutGuides) {
        drawPageCutGuides(backPage, positions, columns, pageWidthMm, pageHeightMm);
    }
    drawCardPlaceholders(
        backPage,
        positions,
        columns,
        pageWidthMm,
        pageHeightMm,
        helveticaFont,
        helveticaBoldFont,
        'back',
        perCardOffsets, // Apply back offsets
        true // Show labels on back
    );

    // Save PDF
    const pdfBytes = await pdfDoc.save();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const blob = new Blob([pdfBytes as any], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);

    const pageName = getPageSizeName(pageWidthMm, pageHeightMm);
    const orientation = portrait ? 'portrait' : 'landscape';
    const hasOffsets = perCardOffsets && Object.keys(perCardOffsets).length > 0;
    const offsetSuffix = hasOffsets ? '_with_offsets' : '';
    const filename = `cutting_template_${pageName}_${columns}x${rows}_${bleedMm}mm_bleed_${orientation}_duplex${offsetSuffix}.pdf`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    setTimeout(() => URL.revokeObjectURL(url), 1000);
}